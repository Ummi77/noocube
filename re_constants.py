
### БИБЛИОТЕКА ВЫРАЖЕНИЙ REGEX ############
# from bonds.re_constants import *


# Поиск круглых скобок
PARANTHIS_EXPR_ = r"\(.+?\)" 


# Поиск содержимого в круглых скобках
PARANTHIS_CONTENT_ = r"\((.+?)\)"

# Получитьсодержимое внешних круглых скобок
OUTER_ROUND_PARENTHIS_CONTENT = r'(\([\s\S]*\))'


# Поиск контента между """  ...  """  (мультилинейные коменты) .  Только один коммент в тексте, первый. Если несколько, то будут глюки - будет текст между коментами тоже ключаться
# * https://stackoverflow.com/questions/36341733/regex-expression-for-multiline-comment-in-python !!!!! 
# * https://stackoverflow.com/questions/74459864/regex-to-find-multiline-comments-in-python-that-contain-a-certain-word !!
BETWEEN_MULTY_COMMENT_ = r'\"""(.*)\"""' # Подправленная коррекция выражения из ссылок


# Поиск контента между двойными кавычками 
BETWEEN_DOUBLE_QUOTES = r'\"(.*)\"'


# Все, кроме того, что внутри [...]. Этот класс символов определяет множество разделителей для  выражений для FULL TEXT SEARCH 
NOT_FTS_DELIMETERS_ = r"[^\+-]" 


# Найти делиметры
FTS_DELIMETERS_ = r"[\+-]" 


# Найти все фигурные скобки с их содержимым
FIGUR_BRACES_ = r"{.*?}"


# Найти все круглые скобки с их содержимым
ROUND_BRACES_ = r"\(.*?\)"


# Найти все фигурные скобки, в которых только заглавные буквы, цифры , '_', '!'. '+' говорит, что может быть любое их количество внутри фигурных скобок. А-Я - включая весь русский алфавит
# Это выражение ищет в частности мемы по системе TLH
regExp = r"{[A-ZА-Я0-9_!]+}"

# Найти все фигурные скобки, в которых только заглавные буквы, цифры , '_', '!'. '+' говорит, что может быть любое их количество внутри фигурных скобок. А-Я - включая весь русский алфавит
# Это выражение ищет в частности мемы по системе TLH
MEMS_WITH_FIGUR = r"{[A-ZА-Я0-9_!]+}"

# # Все, что внутри свмых крайних курглых скобок
# IN_OUTERMOST_ROUND_PARENTHES_ = r"\((.*)\)"


# Найти в тексте url
URL_RE_ = r'(https?://[^\s]+)'


# Найти часть пути файла . начиная с заданного домена
PATH_STARTING_FROM_DOMEN = r'(%SUBDOMEN%/.*)'



# РВ для определения строки с функцией типа def .... :  в кодах .py
DEF_NAME = r"(def[^:]+)"


# Найти строку в тексте с заданным словом (заменить %WORD% на реальный поисковый фрагмент)

LINE_WITH_WORD_ = r".*%WORD%.*"


### --- HTML ТЭГИ и ПР ------------------

# # Найти содержание внутри заданного открывающего тэга и закрывающего (НЕ ТЕСТИРОВАНО). %TAG% заменить реплейсом на реальный маркер тэга
# ПРИМ: Тэг открытия не должен иметь пробелов вначале, а тэг закрытия - вообще не должен иметь пробелов
INNER_CONTIN_OF_DOUBLE_TAG_ = r"<%TAG%[\s\S]*?%TAG%>"


# # Найти содержание внутри тэга (НЕ ТЕСТИРОВАНО). %TAG% заменить реплейсом на реальный маркер тэга
# ПРИМ: Тэг  не должен иметь пробелов вначале
INEER_OF_MONO_TAG_ = r"<%TAG%.*?>"


### END --- HTML ТЭГИ и ПР ------------------



# Название класса со всем, что в скобках аргументов этого класса  (там могут быть родители)
CLASS_NAME_WITH_ROUND_BRACKETS_ = r'(class .*\(.*?\)*?:)'


# Название класса с описанием (!!! Работает с перебоями ???)
CLASS_NAME_WITH_DESCRIPTION_ = r'(class .*\(.*\)[\s\S]*?\""".*\""")'



# # Все, что внутри свмых крайних курглых скобок
# IN_OUTERMOST_ROUND_PARENTHES_ = r"\((.*)\)"

# Поиск файла в тексте с расширением .py
FILE_IN_TEXT = r'([\'].*.py[\'])'




# Цифры между слэшами /398594/
DIGITS_BETWEEN_SLASHES = r"/([0-9]+)/"



DIGITS_ONLY = r"([0-9]+)"


# Слова с точками на конце в стринге
# https://stackoverflow.com/questions/41857132/regex-to-match-words-ending-in-dtproj-with-dots
WORDS_WITH_DOT_AT_END = r"([\w]+)\."

# Могут содержать в себе точки. Главное, что заканчивается на точку массив charicters  
STRINGS_WITH_DOT_AT_END = r"([\w.]+)\."


# ищет группы последовательностей в строке (например последовательность цифр)
# ~ /home/ak/projects/P21_Telegram_Channel_Parsing_Django/telegram_channel_parsing_django/telegram_monitor/local_classes/telegram_manager.py 
# [assemble_book_complects_from_messages_types_sequence()]
# группы, состоящие из 2-ек, оканчивающиеся 1 (напр, 22221, 221, пр)
GROUP_OF_SEQUENCES = r"(2+1)"


























